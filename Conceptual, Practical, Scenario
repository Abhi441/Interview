/////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////Dependency Injection
////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////Conceptual
/////////////////////////////////////////What is dependency Injection and Why is it important ?
Dependency Injection(DI) is a design patter used in Software developemnt to manage dependencies 
between object and promote loose coupling.

////////////////////////////////////////////////////////////////////Explain the diffrence between Dependency Injection and Inversion of control.
Ioc is a principle that says "a class  should not control its dependencies".
//Imagine you go to a restaturent .Instead of cooking food yourself, the resturent provdes food to you .You  don't contol cooking , you only eat. 
DI ia a ways to implement IOC by injecting dependencies (via constructor , property or method) instead of creating them inside.

////////////////////////////////////////////////////////////////What are the type of Dependency Injection , And When you would each ?
1) Constructor Injection(Most common) : 
1) Most common type.
2) When the dependency is required always.

Example :
public class OrderService
{
private readonly IPaymentService _paymentService;

//Constructor Injection
public OrderService(IPaymentService paymentService)
{
_paymentService = paymentService;
}

public void Placement()
{
 _paymentService.ProcessPayment();
}
}

//Property Injection:
1) When dependency is optional.
2)Example : Logging -> a service can work without logging, but if available, it will use it.


//Method Services :
1) Used when dependency is needed only in one method.

/////////////////////////////////////////////////////What are the some challenges using dependencies Injection ?
Dependency Injection is powerful but has some challenges. It can make code harder for beginners, add some extra complexity in samll apps , 
dedugging issue like missing registrations can be tricky and there's a little performance overhead.Also , if overused , ot can lead to too many hidden dependencies .

//////////////////////////////////////////////////////////////Practicle Question
//////////////////////////////How do you implement DI in .NetCore ?
/////With Dependency Injection
public interface IPaymentService
{
 void ProcessPayment();
}

public void ProcessPayment : IPaymentService
{
Console.WriteLine("Payment process.");
}
//
public class OrderService
{
Private readonly IPaymentService _paymentService;
//Dependency Injection via Constructor.
public OrderService(IPaymentService paymentService)
{
_paymentService = paymentService ;
}
}

--> OrderService depends on the IPaymentService interfaces, not the console process payment class.
--> Easily replaced with a mock implementation during testing.


//////////////////////////////////////////What is diffrence between AddTransient , AddScoped , And AddSingleton.

//Singleton
A single instance is shared across the application life cycle.
Service instances are disposed at application shutdown.

builder.Services.AddSingleton<IService, Service>(); //Singleton Service

Example : Application-wise configuration settings , shared caches,Logger service(N LOG , Serilog)

//Scoped
A Single instance is created of the service is created per Scope(e.g , per HTTP Service in a web application).

builder.Services.AddScoped<IService, Service>(); //Scoped Service

Example : User-specific data , transaction, Database Context
//Transient
A new instance of the service is created every time , it is requested.
builder.Services.AddTransient<IService, Service>(); //Transient Service
Example : helper classes , New GUI Number
/////////////////////////////////////////////////////////////////////////////How would you handle circular dependencies in DI ?
üîÑ What is Circular Dependency in DI?

It happens when two or more classes depend on each other directly or indirectly, so DI container gets stuck trying to build them.

Example:

public class ServiceA
{
    private readonly ServiceB _serviceB;
    public ServiceA(ServiceB serviceB) { _serviceB = serviceB; }
}

public class ServiceB
{
    private readonly ServiceA _serviceA;
    public ServiceB(ServiceA serviceA) { _serviceA = serviceA; }
}

Here:

ServiceA needs ServiceB

ServiceB needs ServiceA
‚û°Ô∏è Infinite loop üîÅ



---

‚úÖ How to Handle Circular Dependencies in DI?

1. Re-design the classes (Best Solution)

Usually, circular dependencies are a design smell üö®.

Try to split responsibilities or introduce a third class (mediator).

Example:

Instead of ServiceA ‚Üî ServiceB, make ServiceC handle coordination.






---

2. Use Interfaces instead of concrete classes

Break direct dependency.


public interface IServiceA { }
public class ServiceA : IServiceA { }
public class ServiceB 
{
    private readonly IServiceA _serviceA;
    public ServiceB(IServiceA serviceA) { _serviceA = serviceA; }
}




---

3. Use Lazy Injection (Lazy<T> or Func<T>)

Load dependency only when it‚Äôs really needed, avoiding the infinite loop.


public class ServiceA
{
    private readonly Lazy<ServiceB> _serviceB;
    public ServiceA(Lazy<ServiceB> serviceB) { _serviceB = serviceB; }
}




---

4. Property Injection (rare)

Instead of constructor injection, let DI set the property later.


public class ServiceA
{
    public ServiceB ServiceB { get; set; }
}




---

üè¢ Real-World Example

Database + Logging:

If Repository depends on Logger, and Logger depends on Repository for saving logs ‚Üí circular dependency ‚ùå.

Fix: Let Logger log independently, don‚Äôt make it depend on Repository.


üîÑ What is Circular Dependency in DI?

It happens when two or more classes depend on each other directly or indirectly, so DI container gets stuck trying to build them.

Example:

public class ServiceA
{
    private readonly ServiceB _serviceB;
    public ServiceA(ServiceB serviceB) { _serviceB = serviceB; }
}

public class ServiceB
{
    private readonly ServiceA _serviceA;
    public ServiceB(ServiceA serviceA) { _serviceA = serviceA; }
}

Here:

ServiceA needs ServiceB

ServiceB needs ServiceA
‚û°Ô∏è Infinite loop üîÅ



---

‚úÖ How to Handle Circular Dependencies in DI?

1. Re-design the classes (Best Solution)

Usually, circular dependencies are a design smell üö®.

Try to split responsibilities or introduce a third class (mediator).

Example:

Instead of ServiceA ‚Üî ServiceB, make ServiceC handle coordination.






---

2. Use Interfaces instead of concrete classes

Break direct dependency.


public interface IServiceA { }
public class ServiceA : IServiceA { }
public class ServiceB 
{
    private readonly IServiceA _serviceA;
    public ServiceB(IServiceA serviceA) { _serviceA = serviceA; }
}




---

3. Use Lazy Injection (Lazy<T> or Func<T>)

Load dependency only when it‚Äôs really needed, avoiding the infinite loop.


public class ServiceA
{
    private readonly Lazy<ServiceB> _serviceB;
    public ServiceA(Lazy<ServiceB> serviceB) { _serviceB = serviceB; }
}




---

4. Property Injection (rare)

Instead of constructor injection, let DI set the property later.


public class ServiceA
{
    public ServiceB ServiceB { get; set; }
}




---

üè¢ Real-World Example

Database + Logging:

If Repository depends on Logger, and Logger depends on Repository for saving logs ‚Üí circular dependency ‚ùå.

Fix: Let Logger log independently, don‚Äôt make it depend on Repository.
///////////////////////////////////////////////////////////////////////////What happen if a required denpendencies is not registored in the DI Container.



What happens if a required dependency is NOT registered in the DI container?

üëâ If you try to use (resolve) a dependency that is not registered in the DI container, the application will throw an error at runtime.

In .NET, this error usually looks like:

InvalidOperationException: Unable to resolve service for type 'MyApp.Services.IMyService' 
while attempting to activate 'MyApp.Controllers.HomeController'.


---

üß† Example:

public interface IMyService
{
    string GetData();
}

public class MyService : IMyService
{
    public string GetData() => "Hello from Service!";
}

public class HomeController : ControllerBase
{
    private readonly IMyService _service;

    public HomeController(IMyService service) // dependency needed here
    {
        _service = service;
    }

    [HttpGet]
    public string Get() => _service.GetData();
}

If you forget to register it in Program.cs / Startup.cs like this:

builder.Services.AddScoped<IMyService, MyService>();

When you run the app, it crashes with an exception, because DI container doesn‚Äôt know how to create IMyService.


---

üîë Real-World Impact

If dependency is not registered ‚Üí App won‚Äôt even start properly or API request will fail immediately.

This is why proper DI registration is critical in enterprise apps.



---

‚úÖ Interview-Smart Answer:
"If a required dependency is not registered in the DI container, .NET will throw an InvalidOperationException at runtime because it cannot resolve the service. To avoid this, we must ensure all required dependencies are properly registered in Program.cs or Startup.cs. Tools like unit tests and build-time checks can also help catch missing registrations early."


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////Middleware
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////Conceptual Middleware Question
///////////////////////////////////////////////////////////////////////////////////What is Middleware in ASP.NetCore

Middleware is software that sits in the request-response pipeline and process HTTP request and response in an application.

///////////////////////////////////////////////////////Why is Middleware importantant ?
It provide a modular approaches to add cross-cutting  concerns like logging , authentication and error handling.

////////////////////////////////////////////////////How does Middleware differ from HttpModules in .Net framework.
Middleware is lightweight , modular and uses an explicit pipeline , unlike the eveny- driven approaches of httpModule.

/////////////////////////////////////////////////////////////////////////////////////////PracticleModule












