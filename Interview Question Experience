///////////////////////////////////Deloide
1>Middleware

/////////////////////////Hyland Interview Question
///////coding interview
Arrays and string and linkedlist(stack and ques only linear).
Serching and Sorting
/////////c#
Basic
OOp
Inheritance
/////////Solid Priciple:
sigalton 
All 5 also 
////////////////Sql
sql querying

///////////////////////Simens Technology
Q>Artichecture of Project : https://www.youtube.com/watch?v=X7CGyBZrEh8
Q>Framework that is using in  EntityFramework
Q>How you can add two coloum in table by Entityframework.
Q>What is function.
Q>How can we make one form in another component.



///////////////////////////////
Authentiation,authorisation
How can I consume Api
Swagger(starting point of swagger)

//Interview Mistake
Be Prepared for Team Or zoom.
Plan to revisition once all the question(mindset).

////////////
N - tier Artitecture
Repository Pattern
OOps 
Solid Pattern

///////////////////////////////Gagan
Q> What is Threading in C# ?

Multithreading in C# is a process in which multiple threads work simultaneously. 
It is a process to achieve multitasking. It saves time because multiple tasks are being executed at a time.
To create multithreaded application in C#, we need to use System.Threding namespace.

Q> What is diffence between PUT And Patch 


User
What is the diffence between Put And Patch 
ChatGPT
PUT and PATCH are two HTTP methods used in RESTful API design, and they serve different purposes.

PUT:

The PUT method is used to update or create a resource at a specific URI (Uniform Resource Identifier).
When a client sends a PUT request, it typically includes the full representation of the resource in the request body.
If the resource exists at the specified URI, the PUT request will update it with the new representation provided in the request body.
If the resource does not exist, a new resource will be created at the specified URI with the provided representation.
Example:

http
Copy code
PUT /users/123
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30
}
In this example, the resource representing user with ID 123 is either updated with the new data or created if it doesn't exist.

PATCH:

The PATCH method is used to apply partial modifications to a resource.
When a client sends a PATCH request, it includes only the changes to the resource, not the full representation.
PATCH is useful when you want to update specific fields of a resource without sending the entire representation.
Example:

http
Copy code
PATCH /users/123
Content-Type: application/json

{
  "age": 31
}
In this example, the resource representing user with ID 123 is updated by changing the value of the "age" field to 31. Other fields, if they exist, are not affected unless explicitly specified.

In summary, PUT is used for updating or creating a resource with a full representation, while PATCH is used for applying partial modifications to a resource. The choice between them depends on the specific requirements of the API and the desired behavior for updating resources.

User
can you explain this once again
ChatGPT
Certainly! Let's break down the differences between PUT and PATCH in a simpler way:

PUT:

Purpose: Updating or creating a resource at a specific location (URI).

Request Body: The client sends the complete representation of the resource in the request body.

Effect: If the resource exists at the specified URI, it's updated with the full data provided in the request body. If it doesn't exist, a new resource is created.

Example:

http
Copy code
PUT /users/123
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30
}
This updates or creates a user with ID 123, setting their name to "John Doe" and age to 30.

PATCH:

Purpose: Applying partial modifications to a resource.

Request Body: The client sends only the changes to the resource, not the complete representation.

Effect: The resource is updated with the specific changes provided in the request body. Other fields are unaffected unless explicitly mentioned.

Example:

http
Copy code
PATCH /users/123
Content-Type: application/json

{
  "age": 31
}
This updates the user with ID 123, changing only the age to 31. Other fields remain unchanged unless included in the request.

In short, PUT is for complete updates or creation with full data, while PATCH is for partial updates where only specific changes are applied to the resource.
The choice between them depends on whether you want to send the entire data or just the changes when modifying a resource.

////////////////////////
cts in sql
temp table in sql
middleware
type of routing in sql
direct and indirect in Ado.net
cluster and non cluster in sql
Adapter
directive 
pipe
where is root component is available 
Lasy Loading in Angular
Observable and observer 


///////////////////////////////////////////////////////////////////////////////////////Interview Question From Google
What is Partial class in C#?

Once we create a class we can not create a second one with the same name, unless they are in different namespaces. So, Microsoft decided to change this, with the introduction of something called partial classes.

This means that by using the partial classes we can create 2 classes with the same name within the same namespace.

With Partial Classes multiple developers can work simultaneously with a single class in separate files

Q> What is Model Binding ?
The Model binding will take the data as input it will find the exact name of properties that using in asp.netcore and it will bind the data
The process of binding the HTTP Request data to the parameters of application Controllers or Properties is know as Model Binding.
There are lots of built-in methods and atttributes for model binder.

//////////////////////////////////////////////
1>DeadLock
2>Why Donet Project are used.
3>repository
4>logging
5>ddl and dml
6>window functions
7> Explain how logging works in Asp.Net Core?
Logging is a way of recording what happens in your application, such as errors, warnings, or information. Logging can help you debug and troubleshoot problems, as well as monitor the performance and behavior of your application.

In ASP.NET Core, logging is done by using an ILogger<TCategoryName> object, where TCategoryName is the name of the class or component that is logging. You can get an ILogger<TCategoryName> object from dependency injection (DI), which is a technique for creating and managing objects in your application.

To log something, you call one of the methods of the ILogger<TCategoryName> object, such as LogInformation, LogWarning, or LogError. These methods take a message and optionally some parameters, and write them to one or more logging providers. Logging providers are components that store or display the logs, such as the console, a file, or a database.

You can configure logging by using the Logging section of the appsettings.json file, or by using code in the Program.cs file. You can specify which logging providers to use, what level of logging to use for each provider, and what categories of logs to include or exclude.

For more information on logging in ASP.NET Core, you can check out these resources:

8>What is diffrence between layer artitecture and 3 tire artitecture , what is advantages.Which one is using in your project.
9>Singalton design patter.
//why we are creating singlaton design pattern,instead of object.
The Singleton design pattern is used to ensure that a class has only one instance and provides a global point of access to that instance. There are several reasons why you might choose to use the Singleton pattern instead of creating multiple instances of a class:

Global Access Point:

A Singleton provides a centralized point of access to its instance. This is useful when exactly one object is needed to coordinate actions across the system.
Resource Sharing:

If multiple instances of a class would share and modify the same resource, a Singleton pattern ensures that all modifications are done through the same instance, preventing conflicts and ensuring consistency.
Resource Management:

In some cases, creating multiple instances of a class might be resource-intensive or inefficient. Using a Singleton ensures that there is only one instance, saving resources.
Configuration Management:

Singletons are often used for managing configuration settings or global application state. Having a single instance makes it easy to maintain and manage these settings.
Lazy Initialization:

With a Singleton, you can implement lazy initialization, meaning the instance is created only when it is first requested. This can be beneficial for performance, especially if the initialization process is resource-intensive.
Prevention of Multiple Instances:

Some classes are designed to have only one instance due to their nature or purpose. The Singleton pattern enforces this constraint and ensures that there is only one instance of the class.
Managing Shared Resources:

In scenarios where multiple parts of the application need to share the same resource, a Singleton provides a way to centralize access and modifications to that resource.
Maintaining State:

Singletons are often used to maintain a consistent state across the application. Any changes made to the state are reflected in a single instance.
However, it's important to note that the Singleton pattern also has its drawbacks, such as potential for global state, difficulty in testing, and limited flexibility in certain scenarios. Therefore, it's essential to carefully consider whether the Singleton pattern is appropriate for a particular use case.
10>Diffrence between Scoped and transient.
In ASP.NET Core, services (like classes or components that provide certain functionality) can be registered with different lifetimes, and two common lifetimes are "Scoped" and "Transient." Let's break down the difference between them in simpler terms:

Transient:
What it means:

A service with a transient lifetime is created every time it is requested or injected.
It is short-lived and a new instance is provided whenever someone needs it.
Example:

Think of it like ordering a cup of coffee. Each time you ask for coffee, you get a new cup. The cups are not shared; they are independent.
Scoped:
What it means:

A service with a scoped lifetime is created once per request.
It lives throughout the duration of a single HTTP request. If something requests the service multiple times during the same request, it gets the same instance.
Example:

Imagine you are at a restaurant, and the waiter gives you a menu when you sit down. Throughout your meal, you use the same menu. The menu is specific to your "scope" (your table and your dining experience).
Summary:
Transient:

Created every time requested.
Short-lived, not shared.
New instance for each request.
Scoped:

Created once per request.
Lives throughout a single request.
Shared within the same request scope.
In practical terms, if a service doesn't need to maintain state or share information across different parts of the application, and it's okay to create a new instance each time it's requested, then you might use a transient lifetime.

If a service needs to maintain state or share information within the same request (for example, across different components processing the same HTTP request), you might use a scoped lifetime.
11>Two Method name is used in Startup.cs file.
In a typical ASP.NET Core application, the Startup.cs file is used to configure various aspects of your web application, such as setting up services and defining how the application should respond to HTTP requests. In the Startup.cs file, there are two important methods: ConfigureServices and Configure.

ConfigureServices:
What it does:

This method is responsible for configuring the services that your application will use.
Services can be things like database connections, authentication mechanisms, or other components that your application needs to function.
Why it's important:

It's where you "register" or "configure" the services that your application will use.
This method is called by the framework during application startup.
Example:

If your application needs to connect to a database, you might configure a database service here.
Configure:
What it does:

This method is responsible for setting up how your application responds to HTTP requests.
It defines the middleware pipeline, which are components that process requests and responses as they flow through the application.
Why it's important:

It's where you define how the application handles requests, what kind of responses it sends, and what processing happens in between.
Example:

You might use this method to set up authentication, define routes, or add other middleware components.
Summary:
ConfigureServices:

Configures services that your application will use.
Called at application startup.
Configure:

Configures how your application responds to HTTP requests.
Defines the middleware pipeline.
Also called at application startup.
In simpler terms, ConfigureServices is where you say, "Hey, application, these are the services we're going to need," and Configure is where you say, "Alright, application, this is how we're going to handle requests and responses." Both methods play a crucial role in setting up and configuring your ASP.NET Core application.



//////////////////////////////////////////////////////////////////////////////////////////12>How does you right Authentication in Program.cs file
/////////////////////////////////////////////////////////////////////////13>How does partial class compiles if same name with two class .
What it is:

A partial class in C# is a way to split the definition of a class into multiple files.
Why it's useful:

It allows developers to organize and manage large classes by dividing them into smaller, more manageable parts.
How it works:

When you define a class as partial (partial class MyClass), you can spread the class definition across multiple files.
Each file contains a part of the class. All parts together make up the complete class.
During compilation, the C# compiler combines all the parts into a single class.
Example:
csharp
Copy code
// File1.cs
partial class MyClass
{
    public void Method1()
    {
        // Code for Method1
    }
}

// File2.cs
partial class MyClass
{
    public void Method2()
    {
        // Code for Method2
    }
}

// Main.cs
class Program
{
    static void Main()
    {
        MyClass myObject = new MyClass();
        myObject.Method1();
        myObject.Method2();
    }
}
In this example, MyClass is split into two files (File1.cs and File2.cs). Each file has a part of the class. When the program is compiled, the compiler combines both parts into a single MyClass definition.

Benefits:
Organization:

Helps keep large classes organized by spreading their code across multiple files.
Separation of Concerns:

Each file can focus on a specific aspect or functionality of the class.
Collaboration:

Useful in scenarios where different developers work on different parts of the same class.
Summary:
Partial classes in C# allow you to split the definition of a class into multiple files for better organization and management.
During compilation, the parts of the class from different files are combined to create the complete class.

////////////////////////////////////////////////////////////////////////////////////////////////13>What is global exceptional handling.

Sure, let's break down the concept of global exception handling in simple terms:

Global Exception Handling:
What it is:

Global exception handling is a way to deal with unexpected errors or issues that may occur in your entire application.
Why it's useful:

It provides a centralized mechanism to handle errors, making it easier to manage and log unexpected situations.
How it works:

When an error occurs anywhere in your application (during the execution of code), the global exception handling mechanism captures it before it crashes the program.
Instead of letting the error propagate and potentially cause the application to stop, you can define a set of actions to take when an error occurs.
Example:
csharp
Copy code
class Program
{
    static void Main()
    {
        try
        {
            // Code that might throw an exception
            int result = Divide(10, 0);
            Console.WriteLine("Result: " + result);
        }
        catch (Exception ex)
        {
            // Global exception handling
            Console.WriteLine("An error occurred: " + ex.Message);
        }
    }

    static int Divide(int a, int b)
    {
        // Division operation that might throw an exception
        return a / b;
    }
}
In this example, the Divide method attempts to perform a division operation, which could lead to an exception if b is zero. The try-catch block in the Main method captures any exception that occurs during the execution of the code.

Benefits:
Centralized Handling:

All exceptions can be handled in one central place in your application.
Prevent Crashes:

Helps prevent the entire application from crashing due to unhandled exceptions.
Logging and Reporting:

Allows you to log error details, report issues, or take other actions when an unexpected situation occurs.
Summary:
Global exception handling is like having a safety net for your application. It catches unexpected errors, preventing them from causing the entire application to crash. This mechanism provides a way to gracefully handle errors, log relevant information, and potentially recover from certain issues.

/////////////////////////////////////////////////////////////////////////////////////////13>Excecution of catch block.

In most programming languages, including C# (which is commonly used in ASP.NET Core), the catch blocks are evaluated in the order in which they appear. The first catch block that matches the type of the thrown exception is executed, and subsequent catch blocks are ignored.

Here is an example in C#:

csharp
Copy code
try
{
    // Code that might throw an exception
    int result = Divide(10, 0);
    Console.WriteLine("Result: " + result);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Caught DivideByZeroException: " + ex.Message);
}
catch (ArithmeticException ex)
{
    Console.WriteLine("Caught ArithmeticException: " + ex.Message);
}
catch (Exception ex)
{
    Console.WriteLine("Caught general Exception: " + ex.Message);
}
In this example, if the Divide method throws a DivideByZeroException, the first catch block will be executed, and the subsequent catch blocks will be skipped.

It's important to order your catch blocks from the most specific exception type to the more general ones. If you have a catch block for a more general exception type before a more specific one, the more general block will catch the exception, and subsequent blocks will be ignored.

csharp
Copy code
try
{
    // Code that might throw an exception
    int result = Divide(10, 0);
    Console.WriteLine("Result: " + result);
}
catch (Exception ex)
{
    Console.WriteLine("Caught general Exception: " + ex.Message);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Caught DivideByZeroException: " + ex.Message);  // This block will never be reached
}
In this case, the catch block for Exception will catch the exception, and the more specific DivideByZeroException block will be ignored. Therefore, it's crucial to order catch blocks appropriately based on the exception hierarchy.

///////////////////////////////////////////////////////////////////////13>What is use of cts.


13>What is datatime table, where does it store.
/////////////////////////////////////////////////////////////////////15>Write the basic syntax of store procedure.
CREATE PROCEDURE procedure_name
    @parameter1 datatype,
    @parameter2 datatype,
    ...
AS
    -- SQL statements to define the stored procedure logic
    -- This can include SELECT, INSERT, UPDATE, DELETE, and more

GO

///////////////////////////////////////////////////16>excution flow of sql.
FROM>WHERE>GROUP BY >HAVING > SELECT > ORDER BY > LIMIT.

///////////////////////////////////////////////////////14>What is interceptor.
An interceptor is a service that can modify or handle the HTTP requests and responses that are sent or received by your Angular application.
15>Cogfiguration.Json file.
16>What is last life cycle in Angular.
17>Where does we configure any thing.
/////////////////
Graph
DP
Pririty Ques
Array 
HashMap
String
////////////////////////////
//////////////////////////////////////////////////////////////////////////Associate in Sql
aggregate functions include: AVG, COUNT, SUM, MIN, MAX. 
////////////////////////////////////////////////////Serialisation and deserialisation
Json
Groupby stntax
post,put ,delect.
/////////////////////////Advantage of Enum
1>readability
2>Maintainability
3>
////////////////////Difference between var and dynamic in C#
////////////Var
--->If the variable does not initialized it throw an error.
---->returning values from the function. It can only used as a local variable in function.
/////Dynamic
----->If the variable does not initialized it will not throw an error.
----->It can be used for properties or returning values from the function.
//////////////////////////////////What is LINQ , Diffrent type of LINQ.
LINQ allow you to query and manipulate data using a SQL-like syntax directly within your c# or VB.NET code making
data access and manipulation more intuitive and efficient.

Example : Suppose you have a list of numbers and you want to filter out only the even numbers from it. 

1> Create a List of Numbers: First, let's create a list of numbers in C#:

List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

2> Write a LINQ Query: Next, you write a LINQ query to filter out the even numbers:

var evenNumbers = from num in numbers
                  where num % 2 == 0
                  select num;

In this query:

from num in numbers specifies the data source (the list of numbers).
where num % 2 == 0 filters out only the even numbers.
select num selects the even numbers from the list.

3> Iterate Over the Result: Finally, you can iterate over the result and perform further operations if needed:
foreach (var num in evenNumbers)
{
    Console.WriteLine(num);
}

///////////////////////////////////////////////////Diffrent type of LINQ
1> LINQ to Objects: allows you to query in-memory collections, such as arrays, lists, dictionaries, and other 
IEnumerable<T> implementations

2>LINQ to Entities (Entity Framework Core): Allow data in relational databases using Entity Framework Core.
Allow conceptual model mapped to database tables.

3>LINQ to SQL:
4>LINQ to XML:
5>LINQ to DataSet:

/////////////////////////////////////////////////////////////////////Authentication and Autherization in your Project
Authentication:

User Sign-In: When users visit your website, they are prompted to sign in with their username and password. This process verifies their identity.
Remembering Users: After users sign in, your website remembers them using a special token (e.g., a cookie). This way, they don't have to sign in every time they visit a new page.
Authorization:

Determining Access Rights: Once users are signed in, your website checks what they're allowed to do based on their role or permissions. For example, regular users might only be able to view recipes, while administrators can add or edit recipes.
Restricting Access: If a user tries to perform an action they're not allowed to do (like adding a recipe without being an administrator), your website denies the request and shows an error message.
Real-World Example:

Let's say a user named "Alice" wants to add her special cookie recipe to your website:

Authentication:
Alice visits your website and clicks "Sign In".
She enters her username and password.
Your website verifies her credentials and issues a token to remember her.
Authorization:
Alice navigates to the "Add Recipe" page.
Your website checks her role or permissions and sees that she's just a regular user, not an administrator.
Since Alice doesn't have permission to add recipes, your website denies her request and displays a message saying she needs to be an administrator to do that.
In summary, authentication verifies users' identities, while authorization determines what actions they're allowed to perform based on their roles or permissions. This ensures that only authorized users can access certain features of your website, helping to protect sensitive information and maintain control over who can do what.



Step 1: Setting up ASP.NET Core Identity

First, let's set up ASP.NET Core Identity to handle user authentication and authorization.

csharp
Copy code
// Startup.cs

public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<ApplicationDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));

    services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
        .AddEntityFrameworkStores<ApplicationDbContext>();

    services.AddControllersWithViews();
    services.AddRazorPages();
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // Middleware configurations...
    app.UseAuthentication();
    app.UseAuthorization();

    // Other middleware configurations...
}
Step 2: Creating Controllers and Views

Next, let's create controllers and views for our recipe sharing website. We'll add authorization attributes to restrict access to certain actions.

csharp
Copy code
// RecipesController.cs

[Authorize] // Only authenticated users can access these actions
public class RecipesController : Controller
{
    private readonly ApplicationDbContext _context;

    public RecipesController(ApplicationDbContext context)
    {
        _context = context;
    }

    // GET: Recipes
    public async Task<IActionResult> Index()
    {
        var recipes = await _context.Recipes.ToListAsync();
        return View(recipes);
    }

    // Other actions...
}
csharp
Copy code
// AccountController.cs

[AllowAnonymous] // Allow anonymous access to these actions
public class AccountController : Controller
{
    private readonly SignInManager<IdentityUser> _signInManager;
    private readonly UserManager<IdentityUser> _userManager;

    public AccountController(
        SignInManager<IdentityUser> signInManager,
        UserManager<IdentityUser> userManager)
    {
        _signInManager = signInManager;
        _userManager = userManager;
    }

    // Login action
    [HttpGet]
    public IActionResult Login(string returnUrl = null)
    {
        ViewData["ReturnUrl"] = returnUrl;
        return View();
    }

    [HttpPost]
    [AllowAnonymous]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null)
    {
        // Logic for user login...
    }

    // Other actions...
}
Step 3: Displaying Views

Finally, let's create views to display our website's pages.

html
Copy code
<!-- Index.cshtml (Recipes/Index) -->

@model IEnumerable<Recipe>

<h1>Recipes</h1>

<table class="table">
    <thead>
        <tr>
            <th>Name</th>
            <th>Description</th>
            <!-- More columns... -->
        </tr>
    </thead>
    <tbody>
        @foreach (var recipe in Model)
        {
            <tr>
                <td>@recipe.Name</td>
                <td>@recipe.Description</td>
                <!-- More columns... -->
            </tr>
        }
    </tbody>
</table>
html
Copy code
<!-- Login.cshtml (Account/Login) -->

<h1>Login</h1>

<form asp-controller="Account" asp-action="Login" method="post">
    <!-- Login form fields... -->
</form>
In this example:

We set up ASP.NET Core Identity to handle user authentication and authorization.
Controllers and views are created for displaying recipes and handling user login.
Authorization attributes like [Authorize] and [AllowAnonymous] are used to restrict access to certain actions.
Views are created to display website pages, such as the recipe index and login page.

////////////////////////////////////////////////////////////////////////What is Diffrence between Struct and Class
Definition:
Class: A class is a reference type.
Struct: A struct is a value type.
Inheritance:
Class: Classes support inheritance.
Struct: Structs do not support inheritance.
Performance:
Class: Because classes are reference types, they are allocated on the heap.accessing them involves an extra level
Struct: Structs are value types, and they are typically allocated on the stack.Accessing struct members is generally faster than accessing class members.
Uses:
Class: Classes are commonly used to model complex entities with behavior and state.
Struct: Structs are often used for lightweight objects that represent simple data structures

////////////////////////////////////////////////////What is the Diffrence Between Generic Vs Non Generic
Collection are categorized into two parts Generic and Non Generics
Generic Collection :
Type Safety : Generic collections provide strong type safety.
Usability : Generic collections are more user-friendly because they eliminate the need for explicit casting.
Performance : Generic collections are generally more efficient in terms of both execution speed and memory
because they avoid the overhead of boxing and unboxing.

Non-Generic Collection:
Type Safety : Non-generic collections are not type-safe because they store elements as object types.
Usability : Non-generic collections are less user-friendly because they involve casting and boxing/unboxing.
Performance : Non-generic collections may have performance overhead due to the need for boxing (converting value types to reference types) and unboxing
(converting reference types back to value types).

////////////////////////////////////////////////What is diffrence between ArrayLIst and List
//ArraList :
Type Safety : ArrayList is not type-safe as it can store any type of object.
Performance: ArrayList may be slower due to boxing/unboxing.
Code Readability : ArrayList may require explicit type casting.
.NET Version : ArrayList was introduced in earlier versions of .NET framework (2.0)
Flexibility : List can only store elements of the specified type.
//List
Type Safety : List is Type-safe as it can store elements of a specific type only.
Performance : List performs better as it avoids boxing/unboxing.
.NET Version : List was introduced in .NET 3.0
Flexibility : ArrayList can store elements of any type.

Code Readability : List provides clear type specification to improved readability.

Performance : List performs better as it avoids boxing/unboxing.

/////////////////////////////Principle of Rest API
1> Client-Server Architecture : In our example, the client will be a web browser or a mobile application, while the server will be
an ASP.NET Core web application hosting the RESTful API.

Statelessness:
Each HTTP request from the client to the server will contain all the information needed for the server to process the request. For example, when creating a new blog post, the request will 
include the post data (title, content, etc.), and the server will process the request based on this information.
2> Uniform Interface:
We'll use standard HTTP methods to perform CRUD operations on resources. For example:
GET /api/posts to retrieve all blog posts.
POST /api/posts to create a new blog post.
PUT /api/posts/{id} to update an existing blog post.
DELETE /api/posts/{id} to delete a blog post.






