///////////////////////////////////Deloide
1>Middleware

/////////////////////////Hyland Interview Question
///////coding interview
Arrays and string and linkedlist(stack and ques only linear).
Serching and Sorting
/////////c#
Basic
OOp
Inheritance
/////////Solid Priciple:
sigalton 
All 5 also 
////////////////Sql
sql querying

///////////////////////Simens Technology
Q>Artichecture of Project : https://www.youtube.com/watch?v=X7CGyBZrEh8
Q>Framework that is using in  EntityFramework
Q>How you can add two coloum in table by Entityframework.
Q>What is function.
Q>How can we make one form in another component.



///////////////////////////////
Authentiation,authorisation
How can I consume Api
Swagger(starting point of swagger)

//Interview Mistake
Be Prepared for Team Or zoom.
Plan to revisition once all the question(mindset).

////////////
N - tier Artitecture
Repository Pattern
OOps 
Solid Pattern

///////////////////////////////Gagan
Q> What is Threading in C# ?

Multithreading in C# is a process in which multiple threads work simultaneously. 
It is a process to achieve multitasking. It saves time because multiple tasks are being executed at a time.
To create multithreaded application in C#, we need to use System.Threding namespace.

Q> What is diffence between PUT And Patch 


User
What is the diffence between Put And Patch 
ChatGPT
PUT and PATCH are two HTTP methods used in RESTful API design, and they serve different purposes.

PUT:

The PUT method is used to update or create a resource at a specific URI (Uniform Resource Identifier).
When a client sends a PUT request, it typically includes the full representation of the resource in the request body.
If the resource exists at the specified URI, the PUT request will update it with the new representation provided in the request body.
If the resource does not exist, a new resource will be created at the specified URI with the provided representation.
Example:

http
Copy code
PUT /users/123
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30
}
In this example, the resource representing user with ID 123 is either updated with the new data or created if it doesn't exist.

PATCH:

The PATCH method is used to apply partial modifications to a resource.
When a client sends a PATCH request, it includes only the changes to the resource, not the full representation.
PATCH is useful when you want to update specific fields of a resource without sending the entire representation.
Example:

http
Copy code
PATCH /users/123
Content-Type: application/json

{
  "age": 31
}
In this example, the resource representing user with ID 123 is updated by changing the value of the "age" field to 31. Other fields, if they exist, are not affected unless explicitly specified.

In summary, PUT is used for updating or creating a resource with a full representation, while PATCH is used for applying partial modifications to a resource. The choice between them depends on the specific requirements of the API and the desired behavior for updating resources.

User
can you explain this once again
ChatGPT
Certainly! Let's break down the differences between PUT and PATCH in a simpler way:

PUT:

Purpose: Updating or creating a resource at a specific location (URI).

Request Body: The client sends the complete representation of the resource in the request body.

Effect: If the resource exists at the specified URI, it's updated with the full data provided in the request body. If it doesn't exist, a new resource is created.

Example:

http
Copy code
PUT /users/123
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30
}
This updates or creates a user with ID 123, setting their name to "John Doe" and age to 30.

PATCH:

Purpose: Applying partial modifications to a resource.

Request Body: The client sends only the changes to the resource, not the complete representation.

Effect: The resource is updated with the specific changes provided in the request body. Other fields are unaffected unless explicitly mentioned.

Example:

http
Copy code
PATCH /users/123
Content-Type: application/json

{
  "age": 31
}
This updates the user with ID 123, changing only the age to 31. Other fields remain unchanged unless included in the request.

In short, PUT is for complete updates or creation with full data, while PATCH is for partial updates where only specific changes are applied to the resource.
The choice between them depends on whether you want to send the entire data or just the changes when modifying a resource.

////////////////////////
cts in sql
temp table in sql
middleware
type of routing in sql
direct and indirect in Ado.net
cluster and non cluster in sql
Adapter
directive 
pipe
where is root component is available 
Lasy Loading in Angular
Observable and observer 


///////////////////////////////////////////////////////////////////////////////////////Interview Question From Google
What is Partial class in C#?

Once we create a class we can not create a second one with the same name, unless they are in different namespaces. So, Microsoft decided to change this, with the introduction of something called partial classes.

This means that by using the partial classes we can create 2 classes with the same name within the same namespace.

With Partial Classes multiple developers can work simultaneously with a single class in separate files

Q> What is Model Binding ?
The Model binding will take the data as input it will find the exact name of properties that using in asp.netcore and it will bind the data
The process of binding the HTTP Request data to the parameters of application Controllers or Properties is know as Model Binding.
There are lots of built-in methods and atttributes for model binder.

//////////////////////////////////////////////
1>DeadLock
2>Why Donet Project are used.
3>repository
4>logging
5>ddl and dml
6>window functions
7> Explain how logging works in Asp.Net Core?
Logging is a way of recording what happens in your application, such as errors, warnings, or information. Logging can help you debug and troubleshoot problems, as well as monitor the performance and behavior of your application.

In ASP.NET Core, logging is done by using an ILogger<TCategoryName> object, where TCategoryName is the name of the class or component that is logging. You can get an ILogger<TCategoryName> object from dependency injection (DI), which is a technique for creating and managing objects in your application.

To log something, you call one of the methods of the ILogger<TCategoryName> object, such as LogInformation, LogWarning, or LogError. These methods take a message and optionally some parameters, and write them to one or more logging providers. Logging providers are components that store or display the logs, such as the console, a file, or a database.

You can configure logging by using the Logging section of the appsettings.json file, or by using code in the Program.cs file. You can specify which logging providers to use, what level of logging to use for each provider, and what categories of logs to include or exclude.

For more information on logging in ASP.NET Core, you can check out these resources:

8>What is diffrence between layer artitecture and 3 tire artitecture , what is advantages.Which one is using in your project.
9>Singalton design patter.
//why we are creating singlaton design pattern,instead of object.
The Singleton design pattern is used to ensure that a class has only one instance and provides a global point of access to that instance. There are several reasons why you might choose to use the Singleton pattern instead of creating multiple instances of a class:

Global Access Point:

A Singleton provides a centralized point of access to its instance. This is useful when exactly one object is needed to coordinate actions across the system.
Resource Sharing:

If multiple instances of a class would share and modify the same resource, a Singleton pattern ensures that all modifications are done through the same instance, preventing conflicts and ensuring consistency.
Resource Management:

In some cases, creating multiple instances of a class might be resource-intensive or inefficient. Using a Singleton ensures that there is only one instance, saving resources.
Configuration Management:

Singletons are often used for managing configuration settings or global application state. Having a single instance makes it easy to maintain and manage these settings.
Lazy Initialization:

With a Singleton, you can implement lazy initialization, meaning the instance is created only when it is first requested. This can be beneficial for performance, especially if the initialization process is resource-intensive.
Prevention of Multiple Instances:

Some classes are designed to have only one instance due to their nature or purpose. The Singleton pattern enforces this constraint and ensures that there is only one instance of the class.
Managing Shared Resources:

In scenarios where multiple parts of the application need to share the same resource, a Singleton provides a way to centralize access and modifications to that resource.
Maintaining State:

Singletons are often used to maintain a consistent state across the application. Any changes made to the state are reflected in a single instance.
However, it's important to note that the Singleton pattern also has its drawbacks, such as potential for global state, difficulty in testing, and limited flexibility in certain scenarios. Therefore, it's essential to carefully consider whether the Singleton pattern is appropriate for a particular use case.
10>Diffrence between Scoped and transient.
In ASP.NET Core, services (like classes or components that provide certain functionality) can be registered with different lifetimes, and two common lifetimes are "Scoped" and "Transient." Let's break down the difference between them in simpler terms:

Transient:
What it means:

A service with a transient lifetime is created every time it is requested or injected.
It is short-lived and a new instance is provided whenever someone needs it.
Example:

Think of it like ordering a cup of coffee. Each time you ask for coffee, you get a new cup. The cups are not shared; they are independent.
Scoped:
What it means:

A service with a scoped lifetime is created once per request.
It lives throughout the duration of a single HTTP request. If something requests the service multiple times during the same request, it gets the same instance.
Example:

Imagine you are at a restaurant, and the waiter gives you a menu when you sit down. Throughout your meal, you use the same menu. The menu is specific to your "scope" (your table and your dining experience).
Summary:
Transient:

Created every time requested.
Short-lived, not shared.
New instance for each request.
Scoped:

Created once per request.
Lives throughout a single request.
Shared within the same request scope.
In practical terms, if a service doesn't need to maintain state or share information across different parts of the application, and it's okay to create a new instance each time it's requested, then you might use a transient lifetime.

If a service needs to maintain state or share information within the same request (for example, across different components processing the same HTTP request), you might use a scoped lifetime.
11>Two Method name is used in Startup.cs file.
In a typical ASP.NET Core application, the Startup.cs file is used to configure various aspects of your web application, such as setting up services and defining how the application should respond to HTTP requests. In the Startup.cs file, there are two important methods: ConfigureServices and Configure.

ConfigureServices:
What it does:

This method is responsible for configuring the services that your application will use.
Services can be things like database connections, authentication mechanisms, or other components that your application needs to function.
Why it's important:

It's where you "register" or "configure" the services that your application will use.
This method is called by the framework during application startup.
Example:

If your application needs to connect to a database, you might configure a database service here.
Configure:
What it does:

This method is responsible for setting up how your application responds to HTTP requests.
It defines the middleware pipeline, which are components that process requests and responses as they flow through the application.
Why it's important:

It's where you define how the application handles requests, what kind of responses it sends, and what processing happens in between.
Example:

You might use this method to set up authentication, define routes, or add other middleware components.
Summary:
ConfigureServices:

Configures services that your application will use.
Called at application startup.
Configure:

Configures how your application responds to HTTP requests.
Defines the middleware pipeline.
Also called at application startup.
In simpler terms, ConfigureServices is where you say, "Hey, application, these are the services we're going to need," and Configure is where you say, "Alright, application, this is how we're going to handle requests and responses." Both methods play a crucial role in setting up and configuring your ASP.NET Core application.



//////////////////////////////////////////////////////////////////////////////////////////12>How does you right Authentication in Program.cs file
/////////////////////////////////////////////////////////////////////////13>How does partial class compiles if same name with two class .
What it is:

A partial class in C# is a way to split the definition of a class into multiple files.
Why it's useful:

It allows developers to organize and manage large classes by dividing them into smaller, more manageable parts.
How it works:

When you define a class as partial (partial class MyClass), you can spread the class definition across multiple files.
Each file contains a part of the class. All parts together make up the complete class.
During compilation, the C# compiler combines all the parts into a single class.
Example:
csharp
Copy code
// File1.cs
partial class MyClass
{
    public void Method1()
    {
        // Code for Method1
    }
}

// File2.cs
partial class MyClass
{
    public void Method2()
    {
        // Code for Method2
    }
}

// Main.cs
class Program
{
    static void Main()
    {
        MyClass myObject = new MyClass();
        myObject.Method1();
        myObject.Method2();
    }
}
In this example, MyClass is split into two files (File1.cs and File2.cs). Each file has a part of the class. When the program is compiled, the compiler combines both parts into a single MyClass definition.

Benefits:
Organization:

Helps keep large classes organized by spreading their code across multiple files.
Separation of Concerns:

Each file can focus on a specific aspect or functionality of the class.
Collaboration:

Useful in scenarios where different developers work on different parts of the same class.
Summary:
Partial classes in C# allow you to split the definition of a class into multiple files for better organization and management.
During compilation, the parts of the class from different files are combined to create the complete class.

////////////////////////////////////////////////////////////////////////////////////////////////13>What is global exceptional handling.

Sure, let's break down the concept of global exception handling in simple terms:

Global Exception Handling:
What it is:

Global exception handling is a way to deal with unexpected errors or issues that may occur in your entire application.
Why it's useful:

It provides a centralized mechanism to handle errors, making it easier to manage and log unexpected situations.
How it works:

When an error occurs anywhere in your application (during the execution of code), the global exception handling mechanism captures it before it crashes the program.
Instead of letting the error propagate and potentially cause the application to stop, you can define a set of actions to take when an error occurs.
Example:
csharp
Copy code
class Program
{
    static void Main()
    {
        try
        {
            // Code that might throw an exception
            int result = Divide(10, 0);
            Console.WriteLine("Result: " + result);
        }
        catch (Exception ex)
        {
            // Global exception handling
            Console.WriteLine("An error occurred: " + ex.Message);
        }
    }

    static int Divide(int a, int b)
    {
        // Division operation that might throw an exception
        return a / b;
    }
}
In this example, the Divide method attempts to perform a division operation, which could lead to an exception if b is zero. The try-catch block in the Main method captures any exception that occurs during the execution of the code.

Benefits:
Centralized Handling:

All exceptions can be handled in one central place in your application.
Prevent Crashes:

Helps prevent the entire application from crashing due to unhandled exceptions.
Logging and Reporting:

Allows you to log error details, report issues, or take other actions when an unexpected situation occurs.
Summary:
Global exception handling is like having a safety net for your application. It catches unexpected errors, preventing them from causing the entire application to crash. This mechanism provides a way to gracefully handle errors, log relevant information, and potentially recover from certain issues.

/////////////////////////////////////////////////////////////////////////////////////////13>Excecution of catch block.

In most programming languages, including C# (which is commonly used in ASP.NET Core), the catch blocks are evaluated in the order in which they appear. The first catch block that matches the type of the thrown exception is executed, and subsequent catch blocks are ignored.

Here is an example in C#:

csharp
Copy code
try
{
    // Code that might throw an exception
    int result = Divide(10, 0);
    Console.WriteLine("Result: " + result);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Caught DivideByZeroException: " + ex.Message);
}
catch (ArithmeticException ex)
{
    Console.WriteLine("Caught ArithmeticException: " + ex.Message);
}
catch (Exception ex)
{
    Console.WriteLine("Caught general Exception: " + ex.Message);
}
In this example, if the Divide method throws a DivideByZeroException, the first catch block will be executed, and the subsequent catch blocks will be skipped.

It's important to order your catch blocks from the most specific exception type to the more general ones. If you have a catch block for a more general exception type before a more specific one, the more general block will catch the exception, and subsequent blocks will be ignored.

csharp
Copy code
try
{
    // Code that might throw an exception
    int result = Divide(10, 0);
    Console.WriteLine("Result: " + result);
}
catch (Exception ex)
{
    Console.WriteLine("Caught general Exception: " + ex.Message);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Caught DivideByZeroException: " + ex.Message);  // This block will never be reached
}
In this case, the catch block for Exception will catch the exception, and the more specific DivideByZeroException block will be ignored. Therefore, it's crucial to order catch blocks appropriately based on the exception hierarchy.

///////////////////////////////////////////////////////////////////////13>What is use of cts.


13>What is datatime table, where does it store.
/////////////////////////////////////////////////////////////////////15>Write the basic syntax of store procedure.
CREATE PROCEDURE procedure_name
    @parameter1 datatype,
    @parameter2 datatype,
    ...
AS
    -- SQL statements to define the stored procedure logic
    -- This can include SELECT, INSERT, UPDATE, DELETE, and more

GO

///////////////////////////////////////////////////16>excution flow of sql.
FROM>WHERE>GROUP BY >HAVING > SELECT > ORDER BY > LIMIT.

///////////////////////////////////////////////////////14>What is interceptor.
An interceptor is a service that can modify or handle the HTTP requests and responses that are sent or received by your Angular application.
15>Cogfiguration.Json file.
16>What is last life cycle in Angular.
17>Where does we configure any thing.
/////////////////
Graph
DP
Pririty Ques
Array 
HashMap
String
////////////////////////////
//////////////////////////////////////////////////////////////////////////Associate in Sql
aggregate functions include: AVG, COUNT, SUM, MIN, MAX. 
////////////////////////////////////////////////////Serialisation and deserialisation
Json
Groupby stntax
post,put ,delect.
/////////////////////////Advantage of Enum
1>readability
2>Maintainability
3>



