//////////////////////////Reflection
-->Reflection means loocking inside your code(like classes, methods , properties) at runtime.
It allows your program to know about itself and work types and members dynamically - even if you  didn't hardcode them.

It's like your code holding a miror and saying,
"Hey, what classes, methods , or proprties do I have? Let me check and use them!"

//when to use
Used when your code needs to work with unknown types or flexible data.

code
class program
{
public string Name;
public string Age;
}

class Program
{
static void Main()
{
Type type = typeof(Person);

foreach(var prop in type.GetProperties())
{
 Console.WriteLine(prop.Name);
}
}
}

//
Great 👍 let’s break Reflection in C# into definition, project use, trade-offs, and business impact with very easy words 👇

📝 Definition
Reflection in C# is a feature that lets your program inspect itself at runtime.
Using Reflection, you can look at a class’s properties, methods, constructors, attributes even if you don’t know them at compile time.
You can also create objects, call methods, or access fields dynamically.
👉 Think of it like a mirror 🪞 → your program looks at itself and decides what to do.

💻 Project Use (Buy & Sell Properties App)
In your property application, Reflection can be useful in:

Dynamic Mapping – Suppose you are importing property data from Excel/CSV where column names may change. Using Reflection, you can dynamically map columns to model properties.

Serialization/Deserialization – When converting Property objects into JSON or XML, Reflection is used internally to inspect object properties.

Validation & Custom Attributes – If you create a custom attribute [OwnerOnlyAccess], Reflection helps the system check at runtime whether a user has permission.

✅ Example Code:

public class Property
{
    public int Id { get; set; }
    public string Name { get; set; }
}

var property = new Property { Id = 101, Name = "Luxury Villa" };

// Reflection Example: Get all properties
Type type = property.GetType();
foreach (var prop in type.GetProperties())
{
    Console.WriteLine($"{prop.Name} = {prop.GetValue(property)}");
}
👉 Output:

Id = 101
Name = Luxury Villa
⚖️ Trade-offs
✅ Pros:

Very powerful → dynamic behavior without knowing everything at compile time.
Used in frameworks like ASP.NET Core, Entity Framework, JSON.NET (they all rely on Reflection).
Great for generic solutions (serialization, mapping, dependency injection).
❌ Cons:

Performance overhead → slower than normal method calls.
Harder to debug → since things happen at runtime.
Security risk → can expose private methods/fields if not restricted.
💼 Business Impact
🚀 Flexibility → Your property application can easily handle dynamic data structures without rewriting code.
📉 Risk of slowness → If overused (for every request), it can make the app slower, which may hurt user experience.
🔒 Security concerns → Needs careful handling so attackers can’t misuse Reflection to access private data.
💰 Cost-effective → Reduces development effort because you can build generic reusable logic (e.g., automatic mapping/serialization).
👉 In short:
Reflection = Mirror for your code.
It gives flexibility to inspect and modify objects dynamically, but must be used wisely to avoid performance and security issues.



///////////////////////////
why c# doesnot uses multiple inheritance

-->C# does not support multiple class inheritance to avoid ambiguity(Diamond Problem).
-->But you can use multiple interfaces, which gives flexibility without confusion.
--> Because it can create confusion and conflicts especially when two parent classes have the same method or property name.
--> This is called the diamond Problem - and c# avoids it by not allowing a class to inherit from more than one class.

Real life example
Two bosses -->  diffrent instructions -->  same task --> now you are confuse.

Class A
   /      \
Class B   Class C
   \      /
    Class D

In this scenario, if Class B and Class C both inherit a method from Class A, then Class D could inherit two conflicting versions of that method. C# avoids this ambiguity by allowing only single inheritance,
ensuring that each class has a clear and singular parent class.

//////////////////////////////////////what is diffrence between DbContext and DbSet
DbContext : Manages the connection to the database.
DbSet : Represent a table in the database and provide methods to interact with data in the table
what is DBcontext and DBset.
DbContext :
Think of DbContext as a bridge between your c# code and your database. It is like a manager rthat handles the interaction with database, like retrieving, updating ,and saving data.

what id does : It connects to the database and helps you work the data.
Where it is used : In Entity Framework Core to represent your database connection.

DbSet:
DbSet is like a collection of a special type of data from the database(like a table).It allows yoiu to perform operations(add, delete,update etc.)
on the table.

What it does : Represent a table in your database and gives you access to the rows(records) of the table.
Where it is used : Inside the DbContest to interract with specific table.




















