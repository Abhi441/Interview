//////////////////////////Reflection
-->Reflection means loocking inside your code(like classes, methods , properties) at runtime.
It allows your program to know about itself and work types and members dynamically - even if you  didn't hardcode them.

It's like your code holding a miror and saying,
"Hey, what classes, methods , or proprties do I have? Let me check and use them!"

//when to use
Used when your code needs to work with unknown types or flexible data.

code
class program
{
public string Name;
public string Age;
}

class Program
{
static void Main()
{
Type type = typeof(Person);

foreach(var prop in type.GetProperties())
{
 Console.WriteLine(prop.Name);
}
}
}

//
Great ðŸ‘ letâ€™s break Reflection in C# into definition, project use, trade-offs, and business impact with very easy words ðŸ‘‡

ðŸ“ Definition
Reflection in C# is a feature that lets your program inspect itself at runtime.
Using Reflection, you can look at a classâ€™s properties, methods, constructors, attributes even if you donâ€™t know them at compile time.
You can also create objects, call methods, or access fields dynamically.
ðŸ‘‰ Think of it like a mirror ðŸªž â†’ your program looks at itself and decides what to do.

ðŸ’» Project Use (Buy & Sell Properties App)
In your property application, Reflection can be useful in:

Dynamic Mapping â€“ Suppose you are importing property data from Excel/CSV where column names may change. Using Reflection, you can dynamically map columns to model properties.

Serialization/Deserialization â€“ When converting Property objects into JSON or XML, Reflection is used internally to inspect object properties.

Validation & Custom Attributes â€“ If you create a custom attribute [OwnerOnlyAccess], Reflection helps the system check at runtime whether a user has permission.

âœ… Example Code:

public class Property
{
    public int Id { get; set; }
    public string Name { get; set; }
}

var property = new Property { Id = 101, Name = "Luxury Villa" };

// Reflection Example: Get all properties
Type type = property.GetType();
foreach (var prop in type.GetProperties())
{
    Console.WriteLine($"{prop.Name} = {prop.GetValue(property)}");
}
ðŸ‘‰ Output:

Id = 101
Name = Luxury Villa
âš–ï¸ Trade-offs
âœ… Pros:

Very powerful â†’ dynamic behavior without knowing everything at compile time.
Used in frameworks like ASP.NET Core, Entity Framework, JSON.NET (they all rely on Reflection).
Great for generic solutions (serialization, mapping, dependency injection).
âŒ Cons:

Performance overhead â†’ slower than normal method calls.
Harder to debug â†’ since things happen at runtime.
Security risk â†’ can expose private methods/fields if not restricted.
ðŸ’¼ Business Impact
ðŸš€ Flexibility â†’ Your property application can easily handle dynamic data structures without rewriting code.
ðŸ“‰ Risk of slowness â†’ If overused (for every request), it can make the app slower, which may hurt user experience.
ðŸ”’ Security concerns â†’ Needs careful handling so attackers canâ€™t misuse Reflection to access private data.
ðŸ’° Cost-effective â†’ Reduces development effort because you can build generic reusable logic (e.g., automatic mapping/serialization).
ðŸ‘‰ In short:
Reflection = Mirror for your code.
It gives flexibility to inspect and modify objects dynamically, but must be used wisely to avoid performance and security issues.



///////////////////////////
why c# doesnot uses multiple inheritance

-->C# does not support multiple class inheritance to avoid ambiguity(Diamond Problem).
-->But you can use multiple interfaces, which gives flexibility without confusion.
--> Because it can create confusion and conflicts especially when two parent classes have the same method or property name.
--> This is called the diamond Problem - and c# avoids it by not allowing a class to inherit from more than one class.

Real life example
Two bosses -->  diffrent instructions -->  same task --> now you are confuse.

Class A
   /      \
Class B   Class C
   \      /
    Class D

In this scenario, if Class B and Class C both inherit a method from Class A, then Class D could inherit two conflicting versions of that method. C# avoids this ambiguity by allowing only single inheritance,
ensuring that each class has a clear and singular parent class.

//////////////////////////////////////what is diffrence between DbContext and DbSet
DbContext : Manages the connection to the database.
DbSet : Represent a table in the database and provide methods to interact with data in the table
what is DBcontext and DBset.
DbContext :
Think of DbContext as a bridge between your c# code and your database. It is like a manager rthat handles the interaction with database, like retrieving, updating ,and saving data.

what id does : It connects to the database and helps you work the data.
Where it is used : In Entity Framework Core to represent your database connection.

DbSet:
DbSet is like a collection of a special type of data from the database(like a table).It allows yoiu to perform operations(add, delete,update etc.)
on the table.

What it does : Represent a table in your database and gives you access to the rows(records) of the table.
Where it is used : Inside the DbContest to interract with specific table.




















